<!DOCTYPE html>
<html lang="jp">
  <head>
    <meta charset="utf-8">
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.6.1/dist/tf.min.js"></script>
    <script>
    class Node {
      update() {
      }
      draw() {
      }
    }
    class Board extends Node {
      constructor() {
        super();
      }
      update() {
      }
      draw(context) {
        context.fillStyle = "green";
        context.fillRect(0, 0, Game.size, Game.size);
        const borderWeight = Game.borderWeight;
        const cellWidth = Game.cellWidth;
        context.fillStyle = "black";
        for (let i = 0; i < 9; i++) {
          const pos = (borderWeight + cellWidth) * i;
          context.fillRect(pos, 0, borderWeight, Game.size);
          context.fillRect(0, pos, Game.size, borderWeight);
        }
        if (Game.hoverCellIndex != null) {
          const i = Game.hoverCellIndex;
          const x = i % 8;
          const y = Math.floor(i / 8);
          const left = (borderWeight + cellWidth) * x + 1;
          const top = (borderWeight + cellWidth) * y + 1;
          const width = borderWeight + cellWidth;
          const height = borderWeight + cellWidth;
          // context.font = "48px serif";
          // context.fillText(`${i}`, 10, 50);
          context.beginPath();
          context.rect(left, top, width, height);
          context.strokeStyle = "white" ;
          context.lineWidth = 1 ;
          context.stroke() ;
        }
      }
    }
    class Stone extends Node {
      static black = "黒";
      static white = "白";
      constructor() {
        super();
      }
      update() {
      }
      draw(context) {
      }
      static drawCircle(x, y, color, context, borderWeight, cellWidth) {
        context.beginPath();
        context.arc(
            ((borderWeight + cellWidth) * x) + (cellWidth / 2) + 2,
            ((borderWeight + cellWidth) * y) + (cellWidth / 2) + 2,
            (cellWidth / 2) - 5,
            0 * Math.PI / 180,
            360 * Math.PI / 180,
            false);
        context.fillStyle = color;
        context.fill();
        context.strokeStyle = "black";
        context.lineWidth = 1;
        context.stroke();
      }
    }
    class Game {
      static borderWeight = 2;
      static cellWidth = 0; //(this.size - (Game.borderWeight * 9)) / 8;
      static size = 0;
      static hoverCellIndex = null;
      constructor(parent) {
        const self = this;
        // 描画情報
        this.fps = document.getElementById('fps');
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext('2d');
        this.frameCount = 0;
        this.prevTime = performance.now();
        parent.appendChild(this.canvas);
        this.canvas.onclick = (e) => self.onclick(self, e);
        this.canvas.onmousemove = (e) => self.onmousemove(self, e);
        this.canvas.onmouseout = (e) => self.onmouseout(self, e);
        Game.size = Math.min(document.documentElement.clientWidth, document.documentElement.clientHeight) - 50;
        Game.cellWidth = (Game.size - (Game.borderWeight * 9)) / 8;
        // リバーシ情報
        this.stones = new Array(64).fill(0);
        this.stones[27] = Stone.white;
        this.stones[28] = Stone.black;
        this.stones[35] = Stone.black;
        this.stones[36] = Stone.white;
        this.turn = document.getElementById('turn');
        this.turn.innerText = Stone.black
        this.children = [];
        this.children.push(new Board());
        requestAnimationFrame((timestamp) => this.mainloop(timestamp));
      }
      mainloop(timestamp) {
        this.frameCount++;
        this.update();
        this.draw();
        const now = performance.now();
        const elapsed = (now - this.prevTime);
        if (elapsed > 1000) {
          this.fps.innerText = `${this.frameCount}fps`;
          this.prevTime = performance.now();
          this.frameCount = 0;
        }
        requestAnimationFrame((timestamp) => this.mainloop(timestamp));
      }
      async onclick(self, e) {
        const rect = e.target.getBoundingClientRect();
        const mouseX = e.clientX - Math.floor(rect.left) - 2;
        const mouseY = e.clientY - Math.floor(rect.top) - 2;
        if (mouseX < 0 || mouseY < 0) {
          return;
        }
        const x = Math.floor(mouseX / (Game.borderWeight + Game.cellWidth));
        const y = Math.floor(mouseY / (Game.borderWeight + Game.cellWidth));
        let index = x + (y * 8);
        // console.log(`${mouseX} ${mouseY} ${x} ${y}`);
        if (self.stones[index] != 0) {
          return;
        }
        const turnNo = self.turn.innerText == Stone.black ? Stone.black : Stone.white
        // if (!self.canPut(self.stones, index, turnNo2)) {
        //   return;
        // }
        if (turnNo == Stone.white) {
          index = await self.putByAI(self, turnNo);
        }
        // console.log(self.stones);
        if (!self.put(self, index, turnNo)) {
          return;
        }
        // console.log(self.stones);
        self.turn.innerText = self.turn.innerText == Stone.black ? Stone.white : Stone.black;
        self.showStat();
        // 白を自動で実行
        const turnNo2 = self.turn.innerText == Stone.black ? Stone.black : Stone.white
        index = await self.putByAI(self, turnNo2);
        console.log(index);
        if (!self.put(self, index, turnNo2)) {
          return;
        }
        self.turn.innerText = self.turn.innerText == Stone.black ? Stone.white : Stone.black;
        self.showStat();
      }
      showStat() {
        const label = document.getElementById("stat");
        const b = this.stones.filter(e => e == Stone.black).length;
        const w = this.stones.filter(e => e == Stone.white).length;
        label.innerText = `黒:${b}まい 白:${w}まい`;
      }
      onmousemove(self, e) {
        const rect = e.target.getBoundingClientRect();
        const mouseX = e.clientX - Math.floor(rect.left) - 2;
        const mouseY = e.clientY - Math.floor(rect.top) - 2;
        if (mouseX < 0 || mouseY < 0) {
          return;
        }
        const x = Math.floor(mouseX / (Game.borderWeight + Game.cellWidth));
        const y = Math.floor(mouseY / (Game.borderWeight + Game.cellWidth));
        const index = x + (y * 8);
        Game.hoverCellIndex = index;
      }
      onmouseout(self, e) {
        const rect = e.target.getBoundingClientRect();
        const mouseX = e.clientX - Math.floor(rect.left) - 2;
        const mouseY = e.clientY - Math.floor(rect.top) - 2;
        // if (mouseX < 0 || mouseY < 0) {
        //   return;
        // }
        const x = Math.floor(mouseX / Game.cellWidth);
        const y = Math.floor(mouseY / Game.cellWidth);
        const index = x + (y * 8);
        Game.hoverCellIndex = null;
      }
      async putByAI(self, turnNo) {
        const toPreditionData = () => {
          const get = (no) => {
            // console.log(no);
            return self.stones.map(e => {
              if (e == 0) return 0;
              if (e == no) return 1;
              return 0;
            })
          }
          const to8x8 = (ary) => {
            var tmp = [];
            for(var i = 0; i < ary.length; i += 8) {
              tmp.push(ary.slice(i, i + 8));
            }
            return tmp;
          }
          // console.log(get(Stone.black));
          // console.log(get(Stone.white));
          const playerBoard = to8x8(get(turnNo));
          const enemyBoard = to8x8(get(turnNo == Stone.white ? Stone.black : Stone.white));
          return tf.tensor([[playerBoard, enemyBoard]]);
        }
        const xs = toPreditionData();
        // console.log(xs);
        // load model
        const path = "/reversi/model/model.json";
        const model = await tf.loadGraphModel(path);
        // predict
        const y_pred = await model.predict(xs);
        // y_pred.print();

        // convert to array
        const values = await y_pred.data();
        // console.log(values);
        for(let i = 0, len = values.length; i < len; i += 1) {
          if (self.canPut(self, i, turnNo)) {
            continue;
          }
          values[i] = 0;
        };
        const data = await tf.argMax(values).data();
        // console.log(data[0]);
        return data[0];
      }
      canPut(self, index, turnNo) {
        return self.put(self, index, turnNo, true);
      }
      put(self, index, turnNo, dryRun=false) {
        const getIdx = (pos, x, y) => {
          return (pos.x + x) + ((pos.y + y) * 8);
        }
        const getPos = (index) => {
          const x = index % 8;
          const y = Math.floor(index / 8);
          return { x: x, y: y }
        }
        const currPos = getPos(index);
        // 上下左右に走査する。自分または空セルの場合は中断。
        let flipCount = 0;
        const flip = (f1, f2) => {
          for (let y = 1; y < 8; y++) {
            const i = f1(currPos, y);
            if (i < 0 || 63 < i) {
              continue;
            }
            if (self.stones[i] != 0 && self.stones[i] != turnNo) {
              continue;
            }
            if (y > 1 && self.stones[i] == turnNo) {
              for (const j of f2(i)) {
                flipCount++;
                if (!dryRun) {
                  self.stones[j] = turnNo;
                }
              }
            }
            break;
          }
        }
        // 上
        // 右上
        // 右
        // 右下↘︎
        // 下
        // 左下
        // 左
        // 左上
        flip((currPos, y) => { return getIdx(currPos,      0, y * -1); }, function* (i) { for (let j = i; j < index; j += 8) { yield j; } });
        flip((currPos, y) => { return getIdx(currPos,      y, y * -1); }, function* (i) { for (let j = i; j < index; j += 7) { yield j; } });
        flip((currPos, x) => { return getIdx(currPos,      x,      0); }, function* (i) { for (let j = i; j > index; j -= 1) { yield j; } });
        flip((currPos, x) => { return getIdx(currPos,      x,      x); }, function* (i) { for (let j = i; j > index; j -= 9) { yield j; } });
        flip((currPos, y) => { return getIdx(currPos,      0,      y); }, function* (i) { for (let j = i; j > index; j -= 8) { yield j; } });
        flip((currPos, y) => { return getIdx(currPos, y * -1,      y); }, function* (i) { for (let j = i; j > index; j -= 7) { yield j; } });
        flip((currPos, x) => { return getIdx(currPos, x * -1,      0); }, function* (i) { for (let j = i; j < index; j += 1) { yield j; } });
        flip((currPos, y) => { return getIdx(currPos, y * -1, y * -1); }, function* (i) { for (let j = i; j < index; j += 9) { yield j; } });
        if (flipCount == 0) {
          return false;
        }
        if (!dryRun) {
          self.stones[index] = turnNo;
        }
        return true;
      }
      update(timestamp) {
        // console.log(timestamp);
        for (const iterator of this.children) {
          iterator.update(timestamp);
        }
      }
      draw() {
        Game.size = Math.min(document.documentElement.clientWidth, document.documentElement.clientHeight) - 50;
        Game.cellWidth = (Game.size - (Game.borderWeight * 9)) / 8;

        const size = Game.size;
        const borderWeight = Game.borderWeight;
        const cellWidth = Game.cellWidth;
        const context = this.context;

        this.canvas.width = size;
        this.canvas.height = size;
        context.clearRect(0, 0, size, size);

        for (const iterator of this.children) {
          iterator.draw(context);
        }

        // 石
        for (let i = 0; i < this.stones.length; i++) {
          const stone = this.stones[i];
          const x = i % 8;
          const y = Math.floor(i / 8);
          if (stone == Stone.white) {
            Stone.drawCircle(x, y, "white", this.context, borderWeight, cellWidth);
          }
          if (stone == Stone.black) {
            Stone.drawCircle(x, y, "black", this.context, borderWeight, cellWidth);
          }
        }

      }
    }
    window.onload = function() {
      const div = document.getElementById("board");
      new Game(div);
    }
    </script>
  <div>
    <span>リバーシだよ。</span>
    <button>始める</button>
    <span id="turn"></span><span>の番です。</span>
    <span id="stat"></span>
    <span id="fps"></span>
  </div>
  <div id="board"></div>
  </body>
</html>